# Computer Network

## 5 运输层

|          OSI           |   DoD    |                  TCP/IP协议集                  |
| ---------------------- | -------- | ---------------------------------------------- |
| 应用层；表示层；会话层 | 应用层   | Telnet；FTP；SMTP；DNS；HTTP；以及其他应用协议 |
| 传输层                 | 传输层   | TCP；UDP                                       |
| 网络层                 | 网络层   | ICMP；IP；ARP；RARP                            |
| 数据链路层；物理层     | 网络接口 | 各种通信网络接口（以太网络）（物理网络）       |

### 5.1 运输层协议概述

**进程之间的通信**

- 运输层向它上面的应用层提供通信服务，它属于面向通信服务的最高层，同时也是用户功能中的最低层
- 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能

两个主机进行通信其实就是两个主机中的应用进程互相通信

应用进程之间的通信又称为端到端的通信

运输层的一个重要的功能就是复用和分用，应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务

**运输层协议和网络层协议的主要区别**

- IP 协议的作用范围：提供主机之间的逻辑通信
- TCP 和 UDP 协议的作用范围： 提供进程之间的逻辑通信

TCP 需要将传输的文件分段，传输建立会话，可靠传输，流量控制

UDP 一个数据包就能够完成数据通信，不分段，不需建立会话，不需要流量控制，不可靠传输，用于DNS服务，屏幕广播等等

```Shell
netstat -n    建立会话 外网地址 <---> 内网地址
netstat -nb   查看是哪一个进程建立的会话，找到木马
```
**TCP**

|  端口  |           协议            |
| ------ | ------------------------- |
| `3389` | 远程桌面                  |
| `21`   | FTP 应用层FTP协议         |
| `23`   | TELNET 应用层的Telnet协议 |
| `25`   | SMTP 发邮件               |
| `53`   | DNS                       |

**UDP**

| 端口  | 协议 |
| ----- | ---- |
| `53`  | DNS  |
| `69`  | TFTP |
| `161` | SNMP |
| `520` | RIP  |

**运输层的主要功能**

- 为应用进程之间提供端到端的逻辑通信（但网络层是为主机之间提供逻辑通信）
- 对收到的报文进行差错检测
- 运输层需要有两种不同的运输协议，即面向连接的TCP和无连接的UDP
- TCP协议提供可靠连接，相当于一条全双工信道
- 当传输层采用无连接的UDP协议时，这种逻辑通信信道是一条不可靠信道

**TCP的端口**

- 端口用一个 16bits 的端口号进行标志
- 端口号只是为了标注本计算机应用层中的各进程

三类端口：

|     端口      |                           解析                           |
| ------------- | -------------------------------------------------------- |
| `0-1023`      | 熟知端口                                                 |
| `1024-49151`  | 登记端口号，使用这个端口的进程必须在INNA登记，以防止重复 |
| `49152-65536` | 留给客户进程选择暂时使用                                 |

### 5.2 用户数据报协议UDP

UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检验的功能

虽然UDP用户数据报只能提供不可靠的交付，但UDP开销小，很容易进行传输

```
UDP数据报 = UDP首部 + 应用层报文
IP数据报 = IP首部 + UDP数据报
```

> UDP数据报的首部必要信息只有（源端口，目标端口，长度，校验和）这几个信息，不够20个字节，所以会加上IP数据报首部的一部分信息凑够20个字节（源IP地址，目的IP地址，UDP长度等），这一部分被称为伪首部，仅仅是用来凑够20个字节计算检验和

**常见应用层协议使用的端口**

| 应用层协议 | 传输层协议+端口 |
| ---------- | --------------- |
| HTTP       | TCP+80          |
| HTTPS      | TCP+443         |
| RDP        | TCP+3389        |
| FTP        | TCP+21          |
| 共享文件夹  | TCP+445         |
| SMTP       | TCP+25          |
| POP3       | TCP+110         |
| TELNET     | TCP+23          |
| SQL        | TCP+1433        |
| DNS        | UDP+53          |

**服务和应用层之间的协议的关系**：

- 服务使用 TCP 或 UDP 的端口侦听客户端的请求
- 客户端使用 IP 地址定位服务器，使用目标端口定位服务
- 可以在服务器网卡上设置只开放必要的端口，实现服务器的网络安全

查看服务侦听端口：

```Shell
netstat -an
netstat -n     查看建立的会话
netstat -nb    查看建立会话的进程
telnet [IP] [port] 测试远程计算机某个端口是否打开
```

传输层端口：TCP 6；UDP 7；IGMP 1

### 5.3 传输控制协议TCP

#### 5.3.1 TCP最主要的特点

- TCP是面向连接的运输层协议
- 每一条TCP连接只能有两个端点（endpoint），每一条TCP连接只能是点对点的（一对一）
- TCP提供可靠交付的服务
- TCP提供全双工通信
- 面向字节流

#### 5.3.2 TCP连接

- TCP把连接作为最基本的抽象
- 每一条TCP连接有两个端点
- TCP里阿尼金额的端点不是主机而是套接字（socket）或称插口
- 端口号拼接到（contatenated with）IP地址即构成了套接字

**SOCKET**

```shell
socket = (IP地址：端口号)

* 每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：

TCP连接 ::= {socket1,socket2} = {(IP1:port1),(IP2:port2)}
```

**TCP协议三大要点**

- 如何实现可靠传输
- 如何实现流量控制
- 如何避免网络拥塞

### 5.4 可靠传输的工作原理
#### 5.4.1 停止等待协议

- 无差错情况：A端发送；B端接收，并发送确认；A端收到确认并发送下一组
- 超时重传：A端发送出问题，B端没有收到并且没有发出收到报文，这种情况下，A端超时后重新发送
- 确认丢失：B端发送的确认消息没有被A端接收，这种情况稀缺，A端超时后重新发送，B端丢弃重复的数据。并重传确认信息
- 确认迟到：B端发送的确认消息在超时之后才被A端接收，A端收下确认，但什么都不做（已经发生了“确认丢失”的响应）

这种可靠传输协议被称为ARQ（Automatic Repeat Request），又称自动重传请求（停止等待协议）：

- 优点：简单
- 缺点：信道利用率太低

```shell
U = Td / (Td + RTT + Ta)

U:   信道利用率
Td:  deliver time
RTT: Round Trip Time
Ta:  accept time
```

#### 5.4.2 连续ARQ协议

**流水线传输**

- 发送方可连续发送多个分组，不必每发完一个分组停顿下来等待对方确认
- 提高信道利用率

**累计确认**

- 接收方对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了
- 优点是：容易实现，即使确认丢失也不用重传（只需再重新发送确认即可）
- 缺点是：不能向发送方反映出接收方已经正确收到的所有分组的信息

**GO-BACK-N**

- 如果发送方发了5个分组，中间的第3个数据包丢失了但是4，5已经收到了，接收方只能确认收到前2个连续分组，发送方会重新传输第3-5个数据包
- 这就叫做Go-back-N，表示需要重新传送已经发送的N个分组
- 当通信质量不好的时候，连续ARQ会带来负面影响

**TCP可靠通信的具体实现**

- TCP连接的每一端都必须设有两个窗口：一个发送窗口和一个接受窗口
- TCP的课靠传输机制用字节的序号进行控制
- TCP所有的确认都是基于序号而不是基于报文段
- TCP连接的往返时间RTT也不是固定不变的。需要使用特定的算法估算较为合理的重传时间

### 5.5 TCP报文段的首部格式

|    报文段    | 所占位数大小 |                                                                      解析                                                                       |
| ------------ | ------------ | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| **源端口**   | 16bits       | 端口是运输层与应用层的服务接口                                                                                                                  |
| 目的端口     | 16bits       | 运输层的复用和分用功能都要通过端口才能实现                                                                                                      |
| **序号**     | 32bits       | TCP连接中传输的每一个字节都编上一个序号，序号字段的值则指的是本报文段所发送的数据的第一个字节的序号（初始序号不一定为0，存在序号回绕问题）      |
| **确认号**   | 32bits       | 是期望收到对方的下一个报文段的数据的第一个字节的序号                                                                                            |
| **数据偏移** | 4bits        | 即首部长度，它指出TCP报文段的数据起始处距离TCP报文段起始处有多远。“数据偏移”的单位是32bits                                                      |
| 保留字段     | 6bits        | 保留为今后使用，但目前应置为0                                                                                                                   |
| URG          | 1bit         | 紧急，当URG=1时，表示紧急指针字段有效，它告诉系统此报文段中有紧急数据，应尽快传送（高优先级数据）                                               |
| ACK          | 1bit         | 只有当ACK=1时，确认号字段才有效，ACK=0时，确认号字段无效                                                                                        |
| PSH          | 1bit         | 当接收TCP收到PSH=1时，就尽快交付接收应用进程，而不再等到整个缓存都填满了后再向上交付                                                            |
| RST          | 1bit         | 当RST=1时，表明TCP连接中出现严重差错（如由于主机错误或其他原因），必须释放链接，然后重新建立运输链接                                            |
| SYN          | 1bit         | 当SYN=1时，表明这个一个连接请求或连接接受的报文，此时ACK=0，确认号无效，该报文只用来建立session                                                 |
| FIN          | 1bit         | 当FIN=1时，表明此报文段的发送端的数据已经发送完毕，并要求释放会话连接                                                                           |
| 窗口         | 16bits       | 用来让对方设置发送窗口的依据，单位为字节Byte（设置发送缓存和接收缓存）                                                                          |
| **检验和**   | 16bits       | 检验字段包括TCP首部+数据两部分，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部                                                           |
| 紧急指针     | 16bits       | 指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文数据的最前面）                                                                        |
| **选项**     | 长度可变     | TCP最初只规定了一种选项，即最大报文段长度MSS（Maximum Segment Size）。MSS告诉对方TCP：“我的缓存所能接收的报文段的数据字段的最大长度是MSS个字节” |
| 填充         | 长度可变     | 与选项一同凑够了4字节的整数倍                                                                                                                   |

**SYN攻击器：**

- 通过瞎编地址与目标主机建立会话，然后让目标主机不断发送确认消息，然而却等不到回应，通过这种方式占用主机的CPU资源
- `land.exe`可通过目标地址与源地址重复，让目标主机与自己建立会话，耗尽目标主机资源，最后达到攻击目的，目标主机瘫痪

### 5.6 TCP可靠传输的实现
#### 5.6.1 以字节为单位的滑动窗口

- 根据B给出的窗口值，A构造出自己的发送窗口
- A收到新的确认号，发送窗口向前滑动
- A的发送窗口内的序号都已用完，但还没有收到确认，必须停止发送，产生这种现象的原因是接收方反应速度慢于发送方发送速度

**发送缓存与接收缓存**

- 发送缓存存放准备发送的数据和已发送没有收到确认的数据
- 接收缓存用来存放按序到达的，但尚未被接收应用程序读取的数据和不按序到达的数据

#### 5.6.2 超时重传时间的选择

- TCP每发送一次报文段，就对这个报文段设置一次计时器，只要计时器设置的重传时间到，但还没有收到确认，就要重传这一段报文
- 由于RTT的方差比较大，所以计时器取新RTT和旧RTT的加权平均

### 5.7 TCP的流量控制

- 利用滑动窗口实现流量控制：让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞

**持续计时器**

- TCP为每一个连接设有一个持续计时器
- 只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器
- 若持续计时器设置的时间到期，就发送一个零窗口探测报文，对方在确认这个报文时给出窗口值
- 若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器
- 若窗口不是零，则死锁（吞吐量=0）的僵局就可以打破

### 5.8 TCP的拥塞控制

**开环控制**

- 在设计网络时，事先将有关发生拥塞的因素考虑周全，力求网络在工作时不产生拥塞

**闭环控制**

- 基于反馈环路的概念
- 检测网络系统以便检测到拥塞在何时，何处，发生
- 将拥塞发生的信息传送到可采取行动的地方
- 调整网络系统的运行以解决出现的问题

**慢开始和拥塞避免算法**

- 发送方维持一个叫拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态变化，发送方让自己的发送窗口等于拥塞窗口
- 发送方控制cwnd的原则是：只要网络没有出现拥塞，拥塞窗口就更大一些，以便把多余的分组发送出去，但只要网络出现拥塞，拥塞窗口就要减少一些，以减少到注入到网络中的分组数

慢开始算法的原理

- 控制cwnd指数增长

拥塞避免算法的原理

- 控制cwnd线性增长
- 当慢开始算法控制的cwnd == threshhold 时，采用拥塞避免算法，即先指数增长，后线性增长
- 如果超时现象产生，说明网络拥塞了
- 将阈值设为最大窗口数的一半，cwnd在重新设置为1，并执行慢开始算法

**乘法减小**
（multiplicative decrease）

- 乘法减小是指不论在慢开始阶段还是拥塞避免阶段，只要出现一次超时（即出现一次网络拥塞），就把慢开始门限值ssthresh设置为当前窗口值乘0.5
- 当网络频繁出现拥塞时，ssthresh值就下降的很快，以大大减少注入到网络中的分组数

**加法增大**
（additive increase）

- 加法增大是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞

### 5.9 TCP的运输连接管理

- 运输连接的三个阶段：
- 连接建立，数据传送，连接释放

连接建立过程中要解决三个问题：

- 使每一方能确知对方存在
- 允许双方协商一些参数（如最大报文长度，最大窗口大小，服务质量等）
- 对运输实体资源进行分配（如缓存大小等）

**客户服务器方式**

- 主动发起连接建立的应用进程叫客户（client）
- 被动等待连接建立的应用进程叫服务（server）

**三次握手建立连接**

- A 的 TCP 向 B 发送出连接请求报文，其首部中的同步位SYN=1，并选择序号seq=x，表明传送数据时，第一个数据字节的序号是x
- B 的 TCP 收到连接请求报文段后，如同意，则发回确认；B在确认报文段中应使SYN=1，使ACK=1，其确认号ack = x + 1，自己选择的序号seq=y
- A 收到此报文后向B给出确认，其ACK=1，确认号 = y+1
  

- A的TCP通知上层应用进程，连接已经建立
- B的TCP收到主机A的确认后，也通知其上层应用进程，TCP连接已经建立

为什么要进行第三次握手：如果是两次握手，当Client发送请求，Server收到并发送确认之后，Server就处于连接建立状态，此时如果Client没有收到确认信息，那么就不会进如连接进入状态，迟迟不发送数据，Server等待的过程中会消耗大量的资源。

**TCP建立连接的各个状态**

```shell
============================================
CLIENT    SERVER
============================================
CLOSED    CLOSED
----------------
      \
       \  LISTEN
        \ NO.1 (SYN=1 ACK=0 seq=x)
SYN-     |------     
SENT    /
       / 
      /   NO.2 (SYN=1 ACK=1 ack=x+1 seq=y)
-----|    SYN-RCVD
      \
       \
        \ NO.3 (SYN=0 ACK=1 ack=y+1 seq=x+1)
         |------
ESTA-      ESTA-
BLISHED    BLISHED
----------------
数据传送
============================================
```

**TCP连接的释放**

- 数据传输结束之后，通信的双方都可以释放连接。现在A的应用进程先向其TCP发出连接释放的报文段，并停止再发送数据，主动关闭TCP连接
- A把连接释放报文段首部的FIN=1，其序号seq=u，等待B的确认

- B发出确认，确认号 ack=u+1，而这个报文段自己的序号 seq=v
- TCP服务器进程通知高层应用进程
- 从A到B这个方向的连接就释放了，TCP连接处于半封闭状态，B若发送数据，A仍要接收

- 若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接
- A收到连接释放报文后，必须发出确认

```shell
============================================
CLIENT     SERVER
============================================
ESTA-      ESTA-
BLISHED    BLISHED
-------
       \
        \
FIN-     \ NO.1 (FIN=1 ACK=0 seq=u)
WAIT-1    |-------
         /
        /  NO.2 (FIN=0 ACK=1 ack=u+1 seq=v)
       /   CLOSE-WAIT
------|   --------
         /
FIN-    /
WAIT-2 /   NO.3 (FIN=1 ACK=1 ack=u+1 seq=w)
------|    LAST-ACK
       \
        \
         \ NO.4 (FIN=0 ACK=1 ack=w+1 seq=u+1)
          |-------
TIME-      CLOSED
WAIT       -------
等待2MSL
------
CLOSED
=============================================
```

- A 必须等待2MSL（Max Segment LifeTime）的时间
- 第一，为了保证A发送的最后一个ACK报文段能到达
- 第二，为了防止“已经失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本链接持续的时间所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段