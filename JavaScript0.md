# JavaScript

JavaScript有两本经典书籍，分别是红宝书《JavaScript高级程序设计》与犀牛书《JavaScript权威指南》。相较之下，红宝书对初学者更为友好。读红宝书辅以《Head First JavaScript》应当是最合理的，前者细致全面，逻辑清晰严谨，后者深入浅出，环环相扣。我大概用了10天时间读完了《Head First JavaScript》，本想做一个《Head First JavaScript》的全面总结，然而通读一遍后觉得本书更注重与入门而不是精进，事无巨细地整理一遍显得过于冗余。最后索性看完红宝书，两者进行一番对比，再做总结。

## 0 最佳实践

原本是红宝书第24章的内容，然而我认为这一章太重要了，直接提到文首。

 JavaScript 的最佳实践分成若干类，并在开发过程的不同点上进行处理

### 0.1 可维护性

#### 0.1.1 可维护代码

可维护代码的充要条件：

- 可理解性：其他人可以接手代码并理解其意图和一般途径，而无需开发人员的完整解释

- 直观性：代码中的东西一看就明白，不论其操作过程多么复杂

- 可适应性：代码以一种数据上的变化不要求完全重写的方法进行撰写

- 可扩展性：在代码架构上已考虑未来允许对核心功能进行扩展

- 可调试性：当有Bug时，代码可以给予最够的信息来尽可能直接确定问题所在

#### 0.1.2 代码约定

- **可读性**：
  
  - 采用4空格替代Tab键
  
  - 恰当地使用注释：
    
    1. 函数和方法：描述其目的和用于完成任务所可能使用的算法。陈述事先的假设也很重要，如参数代表什么，函数是否有返回值（这不能从函数定义中推断出来）
    
    2. 大段代码：用于完成单个任务的多行代码应该在前面放一个描述任务的注释
    
    3. 复杂的算法：如果使用了一个独特的方式解决某个问题，则要在注释中解释你是如何做的
    
    4. Hack：处理浏览器差异问题时标注明确这么做的目的

. 变量和函数命名：

- **变量名应为名词**如`car`或`person`

- **函数名应该以动词开始**如`getName()`，返回布尔类型值的函数一般以is开头，如`isEnable()`

- **函数名和函数都应使用合乎逻辑的名字**，长度的问题可以通过后处理和压缩

- **采用驼峰，Pascal，匈牙利等命名法**

- **变量类型透明**：
  
  有三种方式，各有利弊
1. 初始化：定一个变量后，它应该被初始化一个值，来暗示它将来应该如何应用。缺点是：*无法用于函数声明中的函数参数*

```javascript
//通过初始化指定变量类型
var found = false;        //Boolean
var count = -1;           //Number
var name = "";            //String
var person = null;        //Object
```

2. 匈牙利标记法：`o`代表对象，`s`代表字符串，`i`代表整数，`f`代表浮点数，`b`代表布尔型。缺点是：*代码在某种程度上难以阅读*

```javascript
   //用于指定数据类型的匈牙利标记法
   var bFound;               //Boolean
   var iCount;               //Integer
   var sName;                //String
   var oPerson;              //Object
```

3. 类型注释法：类型注释维持了代码的可读性，同时注入了类型信息。类型注释的缺点是：*不能用多行注释一次注释大块的代码，因为类型注释也是多行注释，两者会冲突* ，可以使用逐个单行注释替代

```javascript
        //用于指定类型的类型注释
   var found  /*:Boolean*/ = false;
   var count  /*:int*/     = 10;
   var name   /*:String*/  = "Zijin";
   var person /*:Object*/  = null;
```

#### 0.1.3 松散耦合

应用的某个部分过分依赖于另一部分，代码就是耦合过紧，难于维护。典型问题是：对象直接引用另一个对象，并且当修改其中一个的同时需要修改另外一个。紧密耦合的软件难以维护并且需要经常重写。

因为Web应用所涉及的技术，有多种情况会让它变得耦合过紧。必须小心这些情况，并尽可能维护弱耦合代码。

1. **解耦HTML/JavaScript**：HTML和JS应该完全分离并通过外部文件和使用DOM附加行为来包含JavaScript，更改行为只需要在JS文件中，更改标记只需要在渲染文件中

2. **解耦CSS/JavaScript**：用CSS来控制样式，JS仅仅更改元素的类，而不对样式做调整

3. **解耦应用逻辑/事件处理程序**：将事件处理程序抽象成函数单独分离出去
   
   1. 可以更容易更改触发特定过程的事件，比如鼠标和按键可能会应用相同的事件处理程序
   
   2. 可以在不附加到事件的情况下测试代码，使其更易创建单元测试或者是自动化应用流程

```javascript
/*
    牢记的应用和业务逻辑之间松散耦合的几条原则：
    1. 勿将event对象传递给其他方法；只传来自event对象中所需的数据
    2. 任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行
    3. 任何事件处理程序都应该处理事件，然后将处理转交给应用逻辑
*/
```

#### 0.1.4 编程实践

**尊重对象所有权**：不能修改不属于你的对象，如果你不负责创建或维护某个对象；它的属性或者它的方法，就不可以对他们进行修改

1. 不要为实例或原型添加属性

2. 不要为实例或原型添加方法

3. 不要重定义已存在的方法

可以通过以下方式为对象创建新的功能：

1. 创建包含所需功能的新对象，并用它与相关对象交互

2. 创建自定义类型，继承需要进行修改的类型，然后可以为自定义类型添加额外功能

**避免全局变量**：这里是广义的全局变量，包括变量；显式声明的函数和对象，最多创建一个对象，将变量与函数包含其中

1. 单一的全局量的延伸便是命名空间的概念Namespace，命名空间包括创建一个用于放置功能的对象。一个大对象作为一个容器，定义了其他的对象，用这种方式将功能组合在一起的对象，叫做命名空间

2. 虽然会多写一些代码，但是对于可维护的目的而言是值得的。命名空间有助于确保代码可以在同一个页面上与其他代码以无害的方式一起工作。

**避免与null进行比较**：JS不做任何自动的类型检查，所以它就成了开发人员的责任，因此，在JS代码中很少进行类型检测，最常见的类型检测就是查看某个值是否为null，但是直接将值与null比较是使用过度的，并且常常由于不充分的类型检查导致错误如：

```javascript
/*
    该函数的目的是根据给定的comparator对一个数组进行排序，为了函数能正确执行，values参数必须是数组，但这里的if语句仅仅检查该values是否为null。还有其他的值可以通过if语句，包括字符串，数字，它们会导致函数抛出错误
*/

function sortArray(values){
    if (values != null){            //不推荐
        values.sort(comparator);
    }
}

/*
    避免与null比较，改为如下形式比较合适，可以阻止所有非法值，而且完全用不着null
*/

function sortArray(values){         
    if (values instanceof Array){   //推荐
        values.sort(comparator)
    }
}
```

- 这种验证数组的技术在多框架的网页中不一定是正确工作，因为每一个框架都有其自己的全局对象，因此也有自己的Array构造函数。如果你是从一个框架将数组传送到另一个框架，那么就要另外检查是否存在sort()方法

- 尝试用以下技术替换与null比较的方法：

```javascript
/*
    1. 如果值应为一个引用类型，使用 instanceof 操作符检查其构造函数
    2. 如果值应为一个基本类型，使用 typeof 检查其类型
    3. 如果是希望对象包含某个特定的方法名，则使用 typeof 操作符确保指定的方法存在于对象上
*/
```

**使用常量**：尽管 JavaScript 没有常量的正式概念，但它还是有用的。这种将数据从应用逻辑分离出来的思想，可以在不冒引入错误的风险的同时，就改变数据。

```javascript
   function validate(value){
    if (!value){
        alert("Invalid value!");
        location.href = "/errors/invalid.php";
    }
}

//改为：
var Constants = {
    INVALID_VALUE_MSG: "Invalid value!",
    INVALID_VALUE_URL: "/errors/invalid.php"
};
function validate(value){
    if (!value){
        alert(Constants.INVALID_VALUE_MSG);
        location.href = Constants.INVALID_VALUE_URL
    }
}
```

- 关键在于将数据和使用它的逻辑进行分离，要注意的值的类型如下：
  - **重复值**：任何在多处用到的值都应抽取为一个常量，这就限制了当一个值变了而另一个没有变的时候会造成的错误。这也包含了CSS类名
  
  - **用户界面字符串**：任何用于显示给用户的字符串，都应该被抽取出来以方便国际化（读到这段真是拍案叫绝，当我只想着如何实现功能的时候，高手已经想到了多语言地区应用的国际化问题，真是迷人的细节。抽取出来，意味着更多的变量和更复杂的命名规，这是一组矛盾，但显然如果要开发大型的世界级通用的软件应用，就应该抓住主要矛盾）
  
  - **URLs**：在Web应用中，资源位置容易变更，所以推荐用一个公共地方存放所有的URL
  
  - **任意可能会更改的值**：每当你在用到字面量值（literals）时，你都要问一下自己这个值在未来是不是会变化。如果答案是“是”，那么这个值就应该被提取出来作为一个常量

### 0.2 性能

阅读相关内容后补充

### 0.3 部署

阅读相关内容后补充

### 0.4 总结

JavaScript 中的可维护性部分涉及到下面的代码约定：

1. 来自其他语言中的代码约定可以用于决定何时进行注释，以及如何进行压缩，不过 JavaScript 需要针对其松散类型的性质创造一些特殊的约定

2. 由于 JavaScript 必须与 HTML 和 CSS 共存，所以让各自完全定义其自己的目的非常重要，JS定义行为，HTML定义内容，CSS定义外观

3. 这些职责的混淆会导致难以调试的错误和维护上的问题
