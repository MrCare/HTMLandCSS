# JavaScript

## 4 变量，作用域和内存问题

- 理解基本类型和引用类型的值

- 理解执行环境

- 理解垃圾收集

### 4.1 基本类型和引用类型的值

**基本类型值**：5种基本类型，Undefined，Null，Boolean，Number，String

**引用类型值**：可能由多个值构成的对象

- 将一个值赋给变量的时候，解析器必须确定这个值是基本类型值还是引用类型值，基本类型值是可以操作保存在变量中的实际的值

- 引用类型的值是保存在内存中的对象，一般通过操作“引用”来操作对象

- 在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的，ES放弃了这个传统

#### 4.1.1 动态的属性

- 可以为“引用类型值”添加属性和方法

```javascript
var person = new Object();
person.name = "Nicholas";
alert(person.name);        //"Nicholas"
```

- 无法为“基本类型值”添加属性和方法，虽然不会有报错

```javascript
var name = "Nicholas";
name.age = 27;
alert(name.age)            //undefined
```

#### 4.1.2 复制变量值

- 复制“基本类型值”，得到一个副本

- 复制“引用类型值”，得到一个引用的副本，但是复制后的引用仍然指向同一对象

#### 4.1.3 传递参数

ES中所有参数都是按值传递的，传入“引用型变量”是将其在内存中的地址（指针）复制了一份，给局部变量，因此这个局部变量的变化会反映在函数外部

```javascript
function setName(obj){
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
}

var person = new Object();
setName(person);
alert(person.name);      //"Nicholas"
```

- 当在函数内部重写 obj 时，这个变量引用的是一个局部对象了，而这个局部对象会在函数执行完毕后立即被销毁

#### 4.1.4 检测类型

- 检测“基本类型值”：`typeof`关键字

- 检测“引用类型值”：`instanceof`关键字

### 4.2 执行环境及作用域

- 执行环境（execution context，有时也称“环境”）定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每一个执行环境都有一个与之关联的“**变量对象**”（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但是解析器在处理数据时会在后台使用它

- 全局执行环境是最外围的一个执行环境，根据ES实现所在的宿主环境不同，表示执行环境的对象也不一样，在Web浏览器中，全局执行环境被认为是`window`对象，因此所有全局变量和函数都是作为`window`的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器时才会被销毁）

- 每个函数都有自己的**执行环境**，当执行流进入一个环境时，函数的环境就会被推入一个环境栈中，而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ES程序中的执行流正是这个方便的机制控制着。

- 当代码在一个环境中执行时，会创建变量对象的一个**作用域链（scope chain）**，作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其**活动对象（activation object）**作为变量对象。活动对象在最开始只包含一个变量，即`arguments`对象（这个对象在全局环境中是不存在的）；全局执行环境的变量对象始终都是作用域链中的最后一个对象。

- 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐渐向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）

```javascript
var color = "blue";
function changeColor(){
    var anotherColor = "red";
    function swapColors(){
        var tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
        //这里可以访问color，anotherColor和tempColor
    }
    //这里可以访问color和anotherColor但不能访问tempColor
    swapColors();
}
//这里只能访问color
changeColor();
```

- 函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同

#### 4.2.1 延长作用域链

虽然执行环境的类型总共只有两种：全局和局部（函数），但是还有其他办法来延长作用域：

- 这两个语句会在作用域链前加一个变量对象
  
  - `try-catch`语句的`catch`块
  
  - `with`语句

```javascript
function buildUrl(){
    var qs = "?debug=true";
    with(location){
        var url = href + qs;
    }
    return url;
}
```

#### 4.2.2 没有块级作用域

JavaScript 在`if,for,while`中声明变量，会将变量添加到全局变量中，而其他有块级作用域的语言，如C，C++，Java等，则会将变量在执行完语句之后销毁

- 使用`var`声明的变量会被自动添加到最接近的环境中，在函数内部，最近的环境就是函数的局部环境，在`with`语句中，最接近的环境是函数环境。如果初始化变量时没有使用`var`声明，该变量会自动被添加到全局环境

- 不声明而直接初始化是一个常见的错误

- 当在某个环境中为了读取或写入而引用一个**标识符**时，必须通过搜索来确定该标识符实际代表什么，搜索过程从作用域的前端开始，找到为止，直至找完全局变量

- 变量查询有代价，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。JavaScript引擎在优化标识符查询方面做得不错，因此这个差别可以忽略

### 4.3 垃圾收集

JS有自动的内存回收机制，执行环境会负责管理代码执行过程中使用的内存，按照固定时间间隔周期性回收不用的变量

#### 4.3.1 标记清除

当变量进入环境时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，当变量离开环境时，则将其标记为“离开环境”（针对执行流而言）

- 可以用翻转某个特殊位来记录一个变量何时进入环境，或者维护一个进入，离开环境的列表

- 垃圾收集器在运行的时候会给储存在内存中的所有变量加上标记，然后会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境变量已经无法访问这些变量了，最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占有的内存空间

#### 4.3.2 引用计数

跟踪记录每一个值被引用的次数，当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1，如果同一个值又被赋给另一个变量，则该值的引用次数加1，相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减去1，当值的引用次数变为0时，可以回收其占用的内存空间。

- 这种方式有**循环引用**的严重内存泄漏问题

- 将对象变量设置为null意味着切断变量与它此前引用的值的联系

#### 4.3.3 性能问题

用策略调整垃圾收集机制的运行周期

#### 4.3.4 管理内存

一旦数据不再有用，最好通过将其值设置为 null 来释放其引用，这个做法就叫做“解除引用”，这一做法适用于大多数全局变量和全局对象的属性。局部变量会在他们离开执行环境时自动被解除引用

```javascript
function createPerson(name){
    var localPerson = new Object();
    localPerson.name = name;
    return localPerson;
}

var globalPerson = createPerson("Nicholas");
//手工解除 globalPerson 的引用
globalPerson = null
```

- 解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其收回
